package com.mygdx.game.gameLogic.GameDirector.DifficultyCurve;

import com.mygdx.game.gameLogic.GameDirector.StatisticsInfo;

public class BalancedCurve extends Curves {
    private double enemyGenerationPeriod;
    private int maxNumEnemies;

    public BalancedCurve(double enemyCreateDeltaTCutoff, int maxNumEnemies)
    {
        this.enemyGenerationPeriod = enemyCreateDeltaTCutoff;
        this.maxNumEnemies = maxNumEnemies;
    }


    private static final double STRESS_DIFFICULTY_PORTION = 0.25; // STRESS_DIFFICULTY_PORTION /)1.0 + STRESS_DIFFICULTY_PORTION) is the amount of difficulty generated by stress
    private static double stressDifficulty(final double difficulty, StatisticsInfo statistics)
    {
        final double stressRatio = statistics.getStressLevel();

        final double stressPortion = stressRatio * CURVES_MAX_DIFFICULTY * STRESS_DIFFICULTY_PORTION;

        final double stressedDifficulty = ( difficulty + stressPortion)
                / (1.0 + STRESS_DIFFICULTY_PORTION);

//        System.out.println("Diff: " + stressedDifficulty);

        return stressedDifficulty;
}

    @Override
    public double generateDifficulty(StatisticsInfo statistics) {

        final boolean bEnemyNotTooSoon = statistics.getLastCreatedEnemyDeltaT() > enemyGenerationPeriod;
        final boolean bNotTooManyEnemies = statistics.getNumberOfEnemies() < maxNumEnemies;

        if (bEnemyNotTooSoon && bNotTooManyEnemies) // create enemy
        {
            final double difficulty = random.nextDouble() * CURVES_MAX_DIFFICULTY; //base difficulty, it's a portion of the final difficulty
            final double stressedDifficulty = stressDifficulty(difficulty, statistics);

            return stressedDifficulty ;
        }
        else
            return CURVES_NO_ENEMY_CREATED;
    }
}
